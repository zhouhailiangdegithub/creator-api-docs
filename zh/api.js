window.apimeta = {
  "enums": [
    {
      "name": "AccountGender",
      "namespace": "anysdk.AccountGender",
      "module": "anysdk",
      "description": "统计系统的账号性别"
    },
    {
      "name": "AccountOperate",
      "namespace": "anysdk.AccountOperate",
      "module": "anysdk",
      "description": "统计系统的账号操作"
    },
    {
      "name": "AccountType",
      "namespace": "anysdk.AccountType",
      "module": "anysdk",
      "description": "统计系统的账号类型"
    },
    {
      "name": "AdsPos",
      "namespace": "anysdk.AdsPos",
      "module": "anysdk",
      "description": "广告位置"
    },
    {
      "name": "AdsResultCode",
      "namespace": "anysdk.AdsResultCode",
      "module": "anysdk",
      "description": "广告系统回调"
    },
    {
      "name": "AdsType",
      "namespace": "anysdk.AdsType",
      "module": "anysdk",
      "description": "广告类型"
    },
    {
      "name": "AnimationEventType",
      "namespace": "sp.AnimationEventType",
      "module": "sp",
      "description": "骨骼动画事件类型。"
    },
    {
      "name": "Button.Transition",
      "namespace": "cc.Button.Transition",
      "module": "cc",
      "description": "过渡类型"
    },
    {
      "name": "Camera.ClearFlags",
      "namespace": "cc.Camera.ClearFlags",
      "module": "cc",
      "description": "摄像机清除标记位，决定摄像机渲染时会清除哪些状态"
    },
    {
      "name": "CustomResultCode",
      "namespace": "anysdk.CustomResultCode",
      "module": "anysdk",
      "description": "自定义系统回调"
    },
    {
      "name": "DrawBits",
      "namespace": "cc.DrawBits",
      "module": "cc",
      "description": ""
    },
    {
      "name": "EditBox.InputFlag",
      "namespace": "cc.EditBox.InputFlag",
      "module": "cc",
      "description": "定义了一些用于设置文本显示和文本格式化的标志位。"
    },
    {
      "name": "EditBox.InputMode",
      "namespace": "cc.EditBox.InputMode",
      "module": "cc",
      "description": "输入模式"
    },
    {
      "name": "EditBox.KeyboardReturnType",
      "namespace": "cc.EditBox.KeyboardReturnType",
      "module": "cc",
      "description": "键盘的返回键类型"
    },
    {
      "name": "Graphics.LineCap",
      "namespace": "cc.Graphics.LineCap",
      "module": "cc",
      "description": "线段末端属性"
    },
    {
      "name": "Graphics.LineJoin",
      "namespace": "cc.Graphics.LineJoin",
      "module": "cc",
      "description": "线段拐角属性"
    },
    {
      "name": "Label.HorizontalAlign",
      "namespace": "cc.Label.HorizontalAlign",
      "module": "cc",
      "description": "文本横向对齐类型"
    },
    {
      "name": "Label.Overflow",
      "namespace": "cc.Label.Overflow",
      "module": "cc",
      "description": "Overflow 类型"
    },
    {
      "name": "Label.Type",
      "namespace": "cc.Label.Type",
      "module": "cc",
      "description": "Type 类型"
    },
    {
      "name": "Label.VerticalAlign",
      "namespace": "cc.Label.VerticalAlign",
      "module": "cc",
      "description": "文本垂直对齐类型"
    },
    {
      "name": "Layout.AxisDirection",
      "namespace": "cc.Layout.AxisDirection",
      "module": "cc",
      "description": "布局轴向，只用于 GRID 布局。"
    },
    {
      "name": "Layout.HorizontalDirection",
      "namespace": "cc.Layout.HorizontalDirection",
      "module": "cc",
      "description": "水平方向布局方式"
    },
    {
      "name": "Layout.ResizeMode",
      "namespace": "cc.Layout.ResizeMode",
      "module": "cc",
      "description": "缩放模式"
    },
    {
      "name": "Layout.Type",
      "namespace": "cc.Layout.Type",
      "module": "cc",
      "description": "布局类型"
    },
    {
      "name": "Layout.VerticalDirection",
      "namespace": "cc.Layout.VerticalDirection",
      "module": "cc",
      "description": "垂直方向布局方式"
    },
    {
      "name": "LoadingItems.ItemState",
      "namespace": "cc.LoadingItems.ItemState",
      "module": "cc",
      "description": "LoadingItems 队列中的加载项状态，状态的值可能是 LoadingItems.ItemState.WORKING | LoadingItems.ItemState.COMPLETET | LoadingItems.ItemState.ERROR"
    },
    {
      "name": "Mask.Type",
      "namespace": "cc.Mask.Type",
      "module": "cc",
      "description": "遮罩组件类型"
    },
    {
      "name": "NetworkType",
      "namespace": "cc.NetworkType",
      "module": "cc",
      "description": "网络类型枚举"
    },
    {
      "name": "PageView.Direction",
      "namespace": "cc.PageView.Direction",
      "module": "cc",
      "description": "页面视图滚动类型"
    },
    {
      "name": "PageView.EventType",
      "namespace": "cc.PageView.EventType",
      "module": "cc",
      "description": "滚动视图事件类型"
    },
    {
      "name": "PageView.SizeMode",
      "namespace": "cc.PageView.SizeMode",
      "module": "cc",
      "description": "页面视图每个页面统一的大小类型"
    },
    {
      "name": "PageViewIndicator.Direction",
      "namespace": "cc.PageViewIndicator.Direction",
      "module": "cc",
      "description": "页面视图指示器的摆放方向"
    },
    {
      "name": "ParticleSystem.EmitterMode",
      "namespace": "cc.ParticleSystem.EmitterMode",
      "module": "cc",
      "description": "发射模式"
    },
    {
      "name": "ParticleSystem.PositionType",
      "namespace": "cc.ParticleSystem.PositionType",
      "module": "cc",
      "description": "粒子位置类型"
    },
    {
      "name": "PayResultCode",
      "namespace": "anysdk.PayResultCode",
      "module": "anysdk",
      "description": "支付系统支付请求回调"
    },
    {
      "name": "Prefab.OptimizationPolicy",
      "namespace": "cc.Prefab.OptimizationPolicy",
      "module": "cc",
      "description": "Prefab 创建实例所用的优化策略，配合 Prefab.optimizationPolicy 使用。"
    },
    {
      "name": "ProgressBar.Mode",
      "namespace": "cc.ProgressBar.Mode",
      "module": "cc",
      "description": "进度条模式"
    },
    {
      "name": "PushActionResultCode",
      "namespace": "anysdk.PushActionResultCode",
      "module": "anysdk",
      "description": "推送系统回调"
    },
    {
      "name": "RECResultCode",
      "namespace": "anysdk.RECResultCode",
      "module": "anysdk",
      "description": "录屏系统回调"
    },
    {
      "name": "RayCastType",
      "namespace": "cc.RayCastType",
      "module": "cc",
      "description": "射线检测类型"
    },
    {
      "name": "RigidBodyType",
      "namespace": "cc.RigidBodyType",
      "module": "cc",
      "description": "刚体类型"
    },
    {
      "name": "ScrollView.EventType",
      "namespace": "cc.ScrollView.EventType",
      "module": "cc",
      "description": "滚动视图事件类型"
    },
    {
      "name": "Scrollbar.Direction",
      "namespace": "cc.Scrollbar.Direction",
      "module": "cc",
      "description": "Enum for Scrollbar direction"
    },
    {
      "name": "ShareResultCode",
      "namespace": "anysdk.ShareResultCode",
      "module": "anysdk",
      "description": "分享系统回调"
    },
    {
      "name": "Slider.Direction",
      "namespace": "cc.Slider.Direction",
      "module": "cc",
      "description": "滑动器方向"
    },
    {
      "name": "SocialRetCode",
      "namespace": "anysdk.SocialRetCode",
      "module": "anysdk",
      "description": "社交系统回调"
    },
    {
      "name": "Sprite.FillType",
      "namespace": "cc.Sprite.FillType",
      "module": "cc",
      "description": "填充类型"
    },
    {
      "name": "Sprite.SizeMode",
      "namespace": "cc.Sprite.SizeMode",
      "module": "cc",
      "description": "精灵尺寸调整模式"
    },
    {
      "name": "Sprite.Type",
      "namespace": "cc.Sprite.Type",
      "module": "cc",
      "description": "Sprite 类型"
    },
    {
      "name": "TaskType",
      "namespace": "anysdk.TaskType",
      "module": "anysdk",
      "description": "统计系统的任务类型"
    },
    {
      "name": "Texture2D.Filter",
      "namespace": "cc.Texture2D.Filter",
      "module": "cc",
      "description": "The texture filter mode"
    },
    {
      "name": "Texture2D.PixelFormat",
      "namespace": "cc.Texture2D.PixelFormat",
      "module": "cc",
      "description": "The texture pixel format, default value is RGBA8888,\nyou should note that textures loaded by normal image files (png, jpg) can only support RGBA8888 format,\nother formats are supported by compressed file types or raw data."
    },
    {
      "name": "Texture2D.WrapMode",
      "namespace": "cc.Texture2D.WrapMode",
      "module": "cc",
      "description": "The texture wrap mode"
    },
    {
      "name": "TiledMap.Orientation",
      "namespace": "cc.TiledMap.Orientation",
      "module": "cc",
      "description": "Tiled Map 地图方向。"
    },
    {
      "name": "ToolBarPlace",
      "namespace": "anysdk.ToolBarPlace",
      "module": "anysdk",
      "description": "用户系统悬浮窗位置"
    },
    {
      "name": "UserActionResultCode",
      "namespace": "anysdk.UserActionResultCode",
      "module": "anysdk",
      "description": "用户系统回调"
    },
    {
      "name": "VerticalTextAlignment",
      "namespace": "cc.VerticalTextAlignment",
      "module": "cc",
      "description": ""
    },
    {
      "name": "VideoPlayer.EventType",
      "namespace": "cc.VideoPlayer.EventType",
      "module": "cc",
      "description": "视频事件类型"
    },
    {
      "name": "VideoPlayer.ResourceType",
      "namespace": "cc.VideoPlayer.ResourceType",
      "module": "cc",
      "description": "视频来源"
    },
    {
      "name": "WebView.EventType",
      "namespace": "cc.WebView.EventType",
      "module": "cc",
      "description": "网页视图事件类型"
    },
    {
      "name": "Widget.AlignMode",
      "namespace": "cc.Widget.AlignMode",
      "module": "cc",
      "description": "Widget 的对齐模式，表示 Widget 应该何时刷新。"
    },
    {
      "name": "WrapMode",
      "namespace": "cc.WrapMode",
      "module": "cc",
      "description": "动画使用的循环模式。"
    },
    {
      "name": "audioEngine.AudioState",
      "namespace": "cc.audioEngine.AudioState",
      "module": "cc",
      "description": "声音播放状态"
    },
    {
      "name": "debug.DebugMode",
      "namespace": "cc.debug.DebugMode",
      "module": "cc",
      "description": "调试模式"
    },
    {
      "name": "macro.BlendFactor",
      "namespace": "cc.macro.BlendFactor",
      "module": "cc",
      "description": "混合因子\n可参考: http://www.andersriggelsen.dk/glblendfunc.php"
    },
    {
      "name": "macro.ImageFormat",
      "namespace": "cc.macro.ImageFormat",
      "module": "cc",
      "description": "Image formats"
    },
    {
      "name": "macro.KEY",
      "namespace": "cc.macro.KEY",
      "module": "cc",
      "description": "键盘事件的按键值"
    },
    {
      "name": "macro.TextAlignment",
      "namespace": "cc.macro.TextAlignment",
      "module": "cc",
      "description": ""
    }
  ],
  "classes": [
    {
      "name": "Action",
      "namespace": "cc.Action",
      "module": "cc",
      "description": "Action 类是所有动作类型的基类。"
    },
    {
      "name": "ActionInstant",
      "namespace": "cc.ActionInstant",
      "module": "cc",
      "description": "即时动作，这种动作立即就会执行，继承自 FiniteTimeAction。"
    },
    {
      "name": "ActionInterval",
      "namespace": "cc.ActionInterval",
      "module": "cc",
      "description": "时间间隔动作，这种动作在已定时间内完成，继承 FiniteTimeAction。"
    },
    {
      "name": "ActionManager",
      "namespace": "cc.ActionManager",
      "module": "cc",
      "description": "cc.ActionManager 是可以管理动作的单例类。<br/>\n通常你并不需要直接使用这个类，99%的情况您将使用 CCNode 的接口。<br/>\n但也有一些情况下，您可能需要使用这个类。 <br/>\n例如：\n - 当你想要运行一个动作，但目标不是 CCNode 类型时。 <br/>\n - 当你想要暂停/恢复动作时。 <br/>"
    },
    {
      "name": "AffineTransform",
      "namespace": "cc.AffineTransform",
      "module": "cc",
      "description": "AffineTransform 类代表一个仿射变换矩阵。它基本上是由平移旋转，缩放转变所组成。<br/>"
    },
    {
      "name": "AgentManager",
      "namespace": "anysdk.AgentManager",
      "module": "anysdk",
      "description": "插件管理类"
    },
    {
      "name": "Animation",
      "namespace": "cc.Animation",
      "module": "cc",
      "description": "Animation 组件用于播放动画。\n\nAnimation 提供了一系列可注册的事件：\n - play : 开始播放时\n - stop : 停止播放时\n - pause : 暂停播放时\n - resume : 恢复播放时\n - lastframe : 假如动画循环次数大于 1，当动画播放到最后一帧时\n - finished : 动画播放完成时"
    },
    {
      "name": "Animation.EventType",
      "namespace": "cc.Animation.EventType",
      "module": "cc",
      "description": "Animation 支持的事件类型"
    },
    {
      "name": "AnimationClip",
      "namespace": "cc.AnimationClip",
      "module": "cc",
      "description": "动画剪辑，用于存储动画数据。"
    },
    {
      "name": "AnimationState",
      "namespace": "cc.AnimationState",
      "module": "cc",
      "description": "AnimationState 完全控制动画播放过程。<br/>\n大多数情况下 动画组件 是足够和易于使用的。如果您需要更多的动画控制接口，请使用 AnimationState。"
    },
    {
      "name": "ArmatureDisplay",
      "namespace": "dragonBones.ArmatureDisplay",
      "module": "dragonBones",
      "description": "DragonBones 骨骼动画 <br/>\n<br/>\n(Armature Display 具有对骨骼数据的引用并且存储了骨骼实例的状态，\n它由当前的骨骼动作，slot 颜色，和可见的 slot attachments 组成。<br/>\n多个 Armature Display 可以使用相同的骨骼数据，其中包括所有的动画，皮肤和 attachments。)<br/>"
    },
    {
      "name": "Asset",
      "namespace": "cc.Asset",
      "module": "cc",
      "description": "Creator 中的资源基类。<br/>\n\n您可能需要重写：<br/>\n- createNode <br/>\n- _nativeAsset 的 getset 方法<br/>\n- cc.Object._serialize<br/>\n- cc.Object._deserialize<br/>"
    },
    {
      "name": "AudioClip",
      "namespace": "cc.AudioClip",
      "module": "cc",
      "description": "音频资源类。"
    },
    {
      "name": "AudioSource",
      "namespace": "cc.AudioSource",
      "module": "cc",
      "description": "音频源组件，能对音频剪辑。"
    },
    {
      "name": "BitmapFont",
      "namespace": "cc.BitmapFont",
      "module": "cc",
      "description": "位图字体资源类。"
    },
    {
      "name": "BlockInputEvents",
      "namespace": "cc.BlockInputEvents",
      "module": "cc",
      "description": "该组件将拦截所属节点 bounding box 内的所有输入事件（鼠标和触摸），防止输入穿透到下层节点，一般用于上层 UI 的背景。<br>\n该组件没有任何 API 接口，直接添加到场景即可生效。"
    },
    {
      "name": "BoxCollider",
      "namespace": "cc.BoxCollider",
      "module": "cc",
      "description": "包围盒碰撞组件"
    },
    {
      "name": "Button",
      "namespace": "cc.Button",
      "module": "cc",
      "description": "按钮组件。可以被按下,或者点击。<br/>\n\n按钮可以通过修改 Transition 来设置按钮状态过渡的方式：<br/>\n  -Button.Transition.NONE   // 不做任何过渡<br/>\n  -Button.Transition.COLOR  // 进行颜色之间过渡<br/>\n  -Button.Transition.SPRITE // 进行精灵之间过渡<br/>\n  -Button.Transition.SCALE // 进行缩放过渡<br/>\n\n按钮可以绑定事件（但是必须要在按钮的 Node 上才能绑定事件）：<br/>\n  // 以下事件可以在全平台上都触发<br/>\n  -cc.Node.EventType.TOUCH_START  // 按下时事件<br/>\n  -cc.Node.EventType.TOUCH_Move   // 按住移动后事件<br/>\n  -cc.Node.EventType.TOUCH_END    // 按下后松开后事件<br/>\n  -cc.Node.EventType.TOUCH_CANCEL // 按下取消事件<br/>\n  // 以下事件只在 PC 平台上触发<br/>\n  -cc.Node.EventType.MOUSE_DOWN  // 鼠标按下时事件<br/>\n  -cc.Node.EventType.MOUSE_MOVE  // 鼠标按住移动后事件<br/>\n  -cc.Node.EventType.MOUSE_ENTER // 鼠标进入目标事件<br/>\n  -cc.Node.EventType.MOUSE_LEAVE // 鼠标离开目标事件<br/>\n  -cc.Node.EventType.MOUSE_UP    // 鼠标松开事件<br/>\n  -cc.Node.EventType.MOUSE_WHEEL // 鼠标滚轮事件<br/>"
    },
    {
      "name": "CallbacksInvoker",
      "namespace": "cc.CallbacksInvoker",
      "module": "cc",
      "description": "CallbacksInvoker 用来根据 Key 管理并调用回调方法。"
    },
    {
      "name": "Camera",
      "namespace": "cc.Camera",
      "module": "cc",
      "description": "摄像机在制作卷轴或是其他需要移动屏幕的游戏时比较有用，使用摄像机将会比移动节点来移动屏幕更加高效。"
    },
    {
      "name": "Canvas",
      "namespace": "cc.Canvas",
      "module": "cc",
      "description": ": 作为 UI 根节点，为所有子节点提供视窗四边的位置信息以供对齐，另外提供屏幕适配策略接口，方便从编辑器设置。\n注：由于本节点的尺寸会跟随屏幕拉伸，所以 anchorPoint 只支持 (0.5, 0.5)，否则适配不同屏幕时坐标会有偏差。"
    },
    {
      "name": "CircleCollider",
      "namespace": "cc.CircleCollider",
      "module": "cc",
      "description": "圆形碰撞组件"
    },
    {
      "name": "CoffeeScript",
      "namespace": "cc.CoffeeScript",
      "module": "cc",
      "description": "CoffeeScript 资源类。"
    },
    {
      "name": "Collider",
      "namespace": "cc.Collider",
      "module": "cc",
      "description": "碰撞组件基类"
    },
    {
      "name": "Collider.Box",
      "namespace": "cc.Collider.Box",
      "module": "cc",
      "description": "用来定义包围盒碰撞体"
    },
    {
      "name": "Collider.Circle",
      "namespace": "cc.Collider.Circle",
      "module": "cc",
      "description": "用来定义圆形碰撞体"
    },
    {
      "name": "Collider.Polygon",
      "namespace": "cc.Collider.Polygon",
      "module": "cc",
      "description": "用来定义多边形碰撞体"
    },
    {
      "name": "CollisionManager",
      "namespace": "cc.CollisionManager",
      "module": "cc",
      "description": "一个简单的碰撞组件管理类，用于处理节点之间的碰撞组件是否产生了碰撞，并调用相应回调函数。"
    },
    {
      "name": "Color",
      "namespace": "cc.Color",
      "module": "cc",
      "description": "cc.Color 用于表示颜色。\n\n它包含 RGBA 四个以浮点数保存的颜色分量，每个的值都在 0 到 255 之间。\n\n您也可以通过使用 <a href=\"../modules/cc.html#method_color\" class=\"crosslink\">cc.color</a> 的便捷方法来创建一个新的 Color。"
    },
    {
      "name": "Component",
      "namespace": "cc.Component",
      "module": "cc",
      "description": "所有附加到节点的基类。<br/>\n<br/>\n注意：不允许使用组件的子类构造参数，因为组件是由引擎创建的。"
    },
    {
      "name": "Component.EventHandler",
      "namespace": "cc.Component.EventHandler",
      "module": "cc",
      "description": ""
    },
    {
      "name": "ContainerStrategy",
      "namespace": "cc.ContainerStrategy",
      "module": "cc",
      "description": "<p>cc.game.containerStrategy class is the root strategy class of container's scale strategy,\nit controls the behavior of how to scale the cc.game.container and cc.game.canvas object</p>"
    },
    {
      "name": "ContentStrategy",
      "namespace": "cc.ContentStrategy",
      "module": "cc",
      "description": "<p>cc.ContentStrategy class is the root strategy class of content's scale strategy,\nit controls the behavior of how to scale the scene and setup the viewport for the game</p>"
    },
    {
      "name": "Details",
      "namespace": "cc.Details",
      "module": "cc",
      "description": "包含反序列化时的一些信息"
    },
    {
      "name": "Director",
      "namespace": "cc.Director",
      "module": "cc",
      "description": "<p>\n    注意：用 cc.director 代替 cc.Director。<br/>\n    cc.director 一个管理你的游戏的逻辑流程的单例对象。<br/>\n    由于 cc.director 是一个单例，你不需要调用任何构造函数或创建函数，<br/>\n    使用它的标准方法是通过调用：<br/>\n      - cc.director.methodName();\n    <br/>\n    它创建和处理主窗口并且管理什么时候执行场景。<br/>\n    <br/>\n    cc.director 还负责：<br/>\n     - 初始化 OpenGL 环境。<br/>\n     - 设置OpenGL像素格式。(默认是 RGB565)<br/>\n     - 设置OpenGL缓冲区深度 (默认是 0-bit)<br/>\n     - 设置空白场景的颜色 (默认是 黑色)<br/>\n     - 设置投影 (默认是 3D)<br/>\n     - 设置方向 (默认是 Portrait)<br/>\n   <br/>\n   cc.director 设置了 OpenGL 默认环境 <br/>\n     - GL_TEXTURE_2D   启用。<br/>\n     - GL_VERTEX_ARRAY 启用。<br/>\n     - GL_COLOR_ARRAY  启用。<br/>\n     - GL_TEXTURE_COORD_ARRAY 启用。<br/>\n</p>\n<p>\n  cc.director 也同步定时器与显示器的刷新速率。\n  <br/>\n  特点和局限性: <br/>\n     - 将计时器 & 渲染与显示器的刷新频率同步。<br/>\n     - 只支持动画的间隔 1/60 1/30 & 1/15。<br/>\n</p>"
    },
    {
      "name": "DistanceJoint",
      "namespace": "cc.DistanceJoint",
      "module": "cc",
      "description": "距离关节通过一个固定的长度来约束关节链接的两个刚体。你可以将它想象成一个无质量，坚固的木棍。"
    },
    {
      "name": "DragonBonesAsset",
      "namespace": "dragonBones.DragonBonesAsset",
      "module": "dragonBones",
      "description": "dragonBones 的 骨骼数据。"
    },
    {
      "name": "DragonBonesAtlasAsset",
      "namespace": "dragonBones.DragonBonesAtlasAsset",
      "module": "dragonBones",
      "description": "dragonBones 的骨骼纹理数据。"
    },
    {
      "name": "EditBox",
      "namespace": "cc.EditBox",
      "module": "cc",
      "description": "EditBox 组件，用于获取用户的输入文本。"
    },
    {
      "name": "EqualToFrame",
      "namespace": "cc.EqualToFrame",
      "module": "cc",
      "description": ""
    },
    {
      "name": "EqualToWindow",
      "namespace": "cc.EqualToWindow",
      "module": "cc",
      "description": ""
    },
    {
      "name": "Event",
      "namespace": "cc.Event",
      "module": "cc",
      "description": "包含事件相关信息的对象。"
    },
    {
      "name": "Event.EventAcceleration",
      "namespace": "cc.Event.EventAcceleration",
      "module": "cc",
      "description": "加速度事件"
    },
    {
      "name": "Event.EventCustom",
      "namespace": "cc.Event.EventCustom",
      "module": "cc",
      "description": "自定义事件"
    },
    {
      "name": "Event.EventKeyboard",
      "namespace": "cc.Event.EventKeyboard",
      "module": "cc",
      "description": "键盘事件"
    },
    {
      "name": "Event.EventMouse",
      "namespace": "cc.Event.EventMouse",
      "module": "cc",
      "description": "鼠标事件类型"
    },
    {
      "name": "Event.EventTouch",
      "namespace": "cc.Event.EventTouch",
      "module": "cc",
      "description": "触摸事件"
    },
    {
      "name": "EventTarget",
      "namespace": "cc.EventTarget",
      "module": "cc",
      "description": "事件目标是事件触发时，分派的事件对象，Node 是最常见的事件目标，\n但是其他对象也可以是事件目标。<br/>"
    },
    {
      "name": "FiniteTimeAction",
      "namespace": "cc.FiniteTimeAction",
      "module": "cc",
      "description": "有限时间动作，这种动作拥有时长 duration 属性。"
    },
    {
      "name": "Font",
      "namespace": "cc.Font",
      "module": "cc",
      "description": "字体资源类。"
    },
    {
      "name": "Graphics",
      "namespace": "cc.Graphics",
      "module": "cc",
      "description": ""
    },
    {
      "name": "Intersection",
      "namespace": "cc.Intersection",
      "module": "cc",
      "description": "辅助类，用于测试形状与形状是否相交"
    },
    {
      "name": "Joint",
      "namespace": "cc.Joint",
      "module": "cc",
      "description": "关节类的基类"
    },
    {
      "name": "JsonAsset",
      "namespace": "cc.JsonAsset",
      "module": "cc",
      "description": "JSON 资源类。JSON 文件加载后，将会返回该对象。可以通过其中的 `json` 属性访问解析后的 JSON 对象。<br>\n如果你想要获得 JSON 的原始文本，那么应该修改源文件的后缀为 `.txt`，这样就会加载为一个 `TextAsset` 而不是 `JsonAsset`。"
    },
    {
      "name": "Label",
      "namespace": "cc.Label",
      "module": "cc",
      "description": "文字标签组件"
    },
    {
      "name": "LabelAtlas",
      "namespace": "cc.LabelAtlas",
      "module": "cc",
      "description": "艺术数字字体资源类。"
    },
    {
      "name": "LabelOutline",
      "namespace": "cc.LabelOutline",
      "module": "cc",
      "description": "描边效果组件,用于字体描边,只能用于系统字体"
    },
    {
      "name": "Layout",
      "namespace": "cc.Layout",
      "module": "cc",
      "description": "Layout 组件相当于一个容器，能自动对它的所有子节点进行统一排版。<br>\n注意：<br>\n1.不会考虑子节点的缩放和旋转。<br>\n2.对 Layout 设置后结果需要到下一帧才会更新，除非你设置完以后手动调用 <a href=\"../classes/Layout.html#method_updateLayout\" class=\"crosslink\">updateLayout</a>。"
    },
    {
      "name": "LoadingItems",
      "namespace": "cc.LoadingItems",
      "module": "cc",
      "description": "LoadingItems 是一个加载对象队列，可以用来输送加载对象到加载管线中。<br/>\n请不要直接使用 new 构造这个类的对象，你可以使用 LoadingItems.create 来创建一个新的加载队列，这样可以允许我们的内部对象池回收并重利用加载队列。\n它有一个 map 属性用来存放加载项，在 map 对象中已 url 为 key 值。<br/>\n每个对象都会包含下列属性：<br/>\n- id：该对象的标识，通常与 url 相同。<br/>\n- url：路径 <br/>\n- type: 类型，它这是默认的 URL 的扩展名，可以手动指定赋值。<br/>\n- error：pipeline 中发生的错误将被保存在这个属性中。<br/>\n- content: pipeline 中处理的临时结果，最终的结果也将被存储在这个属性中。<br/>\n- complete：该标志表明该对象是否通过 pipeline 完成。<br/>\n- states：该对象存储每个管道中对象经历的状态，状态可以是 Pipeline.ItemState.WORKING | Pipeline.ItemState.ERROR | Pipeline.ItemState.COMPLETE<br/>\n<br/>\n对象可容纳其他自定义属性。<br/>\n每个 LoadingItems 对象都会在 onComplete 回调之后被销毁，所以请不要持有它的引用并在结束回调之后依赖它的内容执行任何逻辑，有这种需求的话你可以提前复制它的内容。"
    },
    {
      "name": "Manifold",
      "namespace": "cc.Manifold",
      "module": "cc",
      "description": ""
    },
    {
      "name": "ManifoldPoint",
      "namespace": "cc.ManifoldPoint",
      "module": "cc",
      "description": "ManifoldPoint 是接触信息中的接触点信息。它拥有关于几何和接触点的详细信息。\n注意：信息中的冲量用于系统内部缓存，提供的接触力可能不是很准确，特别是高速移动中的碰撞信息。"
    },
    {
      "name": "Mask",
      "namespace": "cc.Mask",
      "module": "cc",
      "description": "遮罩组件"
    },
    {
      "name": "MotionStreak",
      "namespace": "cc.MotionStreak",
      "module": "cc",
      "description": "运动轨迹，用于游戏对象的运动轨迹上实现拖尾渐隐效果。"
    },
    {
      "name": "MotorJoint",
      "namespace": "cc.MotorJoint",
      "module": "cc",
      "description": "马达关节被用来控制两个刚体间的相对运动。\n一个典型的例子是用来控制一个动态刚体相对于地面的运动。"
    },
    {
      "name": "MouseJoint",
      "namespace": "cc.MouseJoint",
      "module": "cc",
      "description": "鼠标关节用于使刚体上的一个点追踪一个指定的世界坐标系下的位置。\n鼠标关节可以指定一个最大的里来施加一个柔和的约束。\n鼠标关节会自动使用 mouse region 节点来注册鼠标事件，并且在触摸移动事件中移动选中的刚体。\n注意：一般鼠标关节只在测试环境中使用。"
    },
    {
      "name": "Node",
      "namespace": "cc.Node",
      "module": "cc",
      "description": "Cocos Creator 场景中的所有节点类。<br/>\n支持的节点事件，请参阅 <a href=\"../classes/Node.EventType.html\" class=\"crosslink\">Node.EventType</a>。"
    },
    {
      "name": "Node.EventType",
      "namespace": "cc.Node.EventType",
      "module": "cc",
      "description": "Node 支持的事件类型"
    },
    {
      "name": "NodePool",
      "namespace": "cc.NodePool",
      "module": "cc",
      "description": "cc.NodePool 是用于管理节点对象的对象缓存池。<br/>\n它可以帮助您提高游戏性能，适用于优化对象的反复创建和销毁<br/>\n以前 cocos2d-x 中的 cc.pool 和新的节点事件注册系统不兼容，因此请使用 cc.NodePool 来代替。\n\n新的 NodePool 需要实例化之后才能使用，每种不同的节点对象池需要一个不同的对象池实例，这里的种类对应于游戏中的节点设计，一个 prefab 相当于一个种类的节点。<br/>\n在创建缓冲池时，可以传入一个包含 unuse, reuse 函数的组件类型用于节点的回收和复用逻辑。<br/>\n\n一些常见的用例是：<br/>\n     1.在游戏中的子弹（死亡很快，频繁创建，对其他对象无副作用）<br/>\n     2.糖果粉碎传奇中的木块（频繁创建）。\n     等等...."
    },
    {
      "name": "OriginalContainer",
      "namespace": "cc.OriginalContainer",
      "module": "cc",
      "description": ""
    },
    {
      "name": "PageView",
      "namespace": "cc.PageView",
      "module": "cc",
      "description": "页面视图组件"
    },
    {
      "name": "PageViewIndicator",
      "namespace": "cc.PageViewIndicator",
      "module": "cc",
      "description": "页面视图每页标记组件"
    },
    {
      "name": "ParticleAsset",
      "namespace": "cc.ParticleAsset",
      "module": "cc",
      "description": "Class for particle asset handling."
    },
    {
      "name": "ParticleSystem",
      "namespace": "cc.ParticleSystem",
      "module": "cc",
      "description": "Particle System base class. <br/>\nAttributes of a Particle System:<br/>\n - emmision rate of the particles<br/>\n - Gravity Mode (Mode A): <br/>\n - gravity <br/>\n - direction <br/>\n - speed +-  variance <br/>\n - tangential acceleration +- variance<br/>\n - radial acceleration +- variance<br/>\n - Radius Mode (Mode B):      <br/>\n - startRadius +- variance    <br/>\n - endRadius +- variance      <br/>\n - rotate +- variance         <br/>\n - Properties common to all modes: <br/>\n - life +- life variance      <br/>\n - start spin +- variance     <br/>\n - end spin +- variance       <br/>\n - start size +- variance     <br/>\n - end size +- variance       <br/>\n - start color +- variance    <br/>\n - end color +- variance      <br/>\n - life +- variance           <br/>\n - blending function          <br/>\n - texture                    <br/>\n<br/>\ncocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).<br/>\n'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,  <br/>\ncocos2d uses a another approach, but the results are almost identical.<br/>\ncocos2d supports all the variables used by Particle Designer plus a bit more:  <br/>\n - spinning particles (supported when using ParticleSystem)       <br/>\n - tangential acceleration (Gravity mode)                               <br/>\n - radial acceleration (Gravity mode)                                   <br/>\n - radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only) <br/>\nIt is possible to customize any of the above mentioned properties in runtime. Example:   <br/>"
    },
    {
      "name": "PhysicsBoxCollider",
      "namespace": "cc.PhysicsBoxCollider",
      "module": "cc",
      "description": ""
    },
    {
      "name": "PhysicsChainCollider",
      "namespace": "cc.PhysicsChainCollider",
      "module": "cc",
      "description": ""
    },
    {
      "name": "PhysicsCircleCollider",
      "namespace": "cc.PhysicsCircleCollider",
      "module": "cc",
      "description": ""
    },
    {
      "name": "PhysicsCollider",
      "namespace": "cc.PhysicsCollider",
      "module": "cc",
      "description": ""
    },
    {
      "name": "PhysicsContact",
      "namespace": "cc.PhysicsContact",
      "module": "cc",
      "description": "物理接触会在开始和结束碰撞之间生成，并作为参数传入到碰撞回调函数中。\n注意：传入的物理接触会被系统进行重用，所以不要在使用中缓存里面的任何信息。"
    },
    {
      "name": "PhysicsImpulse",
      "namespace": "cc.PhysicsImpulse",
      "module": "cc",
      "description": "用于返回给回调的接触冲量。"
    },
    {
      "name": "PhysicsManager",
      "namespace": "cc.PhysicsManager",
      "module": "cc",
      "description": "物理系统将 box2d 作为内部物理系统，并且隐藏了大部分 box2d 实现细节（比如创建刚体，同步刚体信息到节点中等）。\n你可以通过物理系统访问一些 box2d 常用的功能，比如点击测试，射线测试，设置测试信息等。\n物理系统还管理碰撞信息的分发，她会在产生碰撞时，将碰撞信息分发到各个碰撞回调中。\n注意：你需要先在刚体中开启碰撞接听才会产生相应的碰撞回调。"
    },
    {
      "name": "PhysicsPolygonCollider",
      "namespace": "cc.PhysicsPolygonCollider",
      "module": "cc",
      "description": ""
    },
    {
      "name": "PhysicsRayCastResult",
      "namespace": "cc.PhysicsRayCastResult",
      "module": "cc",
      "description": ""
    },
    {
      "name": "Pipeline",
      "namespace": "cc.Pipeline",
      "module": "cc",
      "description": "pipeline 描述了一系列的操作，每个操作都被称为 pipe。<br/>\n它被设计来做加载过程的流程管理。所以 item 应该是 url，并且该 url 将是在处理中的每个 item 的身份标识。<br/>\n一个 item 列表可以在 pipeline 中流动，它将输出加载项经过所有 pipe 之后的结果。<br/>\n它们穿过 pipeline 就像水在管子里流动，将会按顺序流过每个 pipe。<br/>\n最后当所有加载项都流出 pipeline 时，整个加载流程就结束了。"
    },
    {
      "name": "Pipeline.Downloader",
      "namespace": "cc.Pipeline.Downloader",
      "module": "cc",
      "description": "The downloader pipe, it can download several types of files:\n1. Text\n2. Image\n3. Script\n4. Audio\n5. Assets\nAll unknown type will be downloaded as plain text.\nYou can pass custom supported types in the constructor."
    },
    {
      "name": "Pipeline.Loader",
      "namespace": "cc.Pipeline.Loader",
      "module": "cc",
      "description": "The loader pipe, it can load several types of files:\n1. Images\n2. JSON\n3. Plist\n4. Audio\n5. Font\n6. Cocos Creator scene\nIt will not interfere with items of unknown type.\nYou can pass custom supported types in the constructor."
    },
    {
      "name": "Playable",
      "namespace": "cc.Playable",
      "module": "cc",
      "description": ""
    },
    {
      "name": "PluginParam",
      "namespace": "anysdk.PluginParam",
      "module": "anysdk",
      "description": "数据结构类"
    },
    {
      "name": "PluginProtocol",
      "namespace": "anysdk.PluginProtocol",
      "module": "anysdk",
      "description": "插件协议"
    },
    {
      "name": "PolygonCollider",
      "namespace": "cc.PolygonCollider",
      "module": "cc",
      "description": "多边形碰撞组件"
    },
    {
      "name": "Pool",
      "namespace": "js.Pool",
      "module": "js",
      "description": "长度固定的对象缓存池，可以用来缓存各种对象类型。<br/>\n这个对象池的实现非常精简，它可以帮助您提高游戏性能，适用于优化对象的反复创建和销毁。"
    },
    {
      "name": "Prefab",
      "namespace": "cc.Prefab",
      "module": "cc",
      "description": "预制资源类。"
    },
    {
      "name": "PrismaticJoint",
      "namespace": "cc.PrismaticJoint",
      "module": "cc",
      "description": "移动关节指定了只能在一个方向上移动刚体。\n你可以开启关节限制来设置刚体运行移动的间距，也可以开启马达来使用关节马达驱动刚体的运行。"
    },
    {
      "name": "PrivateNode",
      "namespace": "cc.PrivateNode",
      "module": "cc",
      "description": "Cocos Creator 场景中的私有节点类。<br/>\n私有节点在编辑器中不可见，对用户透明。<br/>\n通常私有节点是被一些特殊的组件创建出来作为父节点的一部分而存在的，理论上来说，它们不是子节点，而是父节点的组成部分。<br/>\n私有节点有两个非常重要的特性：<br/>\n1. 它有着最小的渲染排序的 Z 轴深度，并且无法被更改，因为它们不能被显示在其他正常子节点之上。<br/>\n2. 它的定位也是特殊的，对于私有节点来说，父节点包围盒的左下角是它的局部坐标系原点，这个原点相当于父节点的位置减去它锚点的偏移。这样私有节点可以比较容易被控制在包围盒之中。<br/>\n目前在引擎中，RichText 和 TileMap 都有可能生成私有节点。"
    },
    {
      "name": "ProgressBar",
      "namespace": "cc.ProgressBar",
      "module": "cc",
      "description": "进度条组件，可用于显示加载资源时的进度。"
    },
    {
      "name": "ProportionalToFrame",
      "namespace": "cc.ProportionalToFrame",
      "module": "cc",
      "description": ""
    },
    {
      "name": "ProportionalToWindow",
      "namespace": "cc.ProportionalToWindow",
      "module": "cc",
      "description": ""
    },
    {
      "name": "ProtocolAdTracking",
      "namespace": "anysdk.ProtocolAdTracking",
      "module": "anysdk",
      "description": "广告追踪系统协议接口"
    },
    {
      "name": "ProtocolAds",
      "namespace": "anysdk.ProtocolAds",
      "module": "anysdk",
      "description": "广告系统协议接口"
    },
    {
      "name": "ProtocolAnalytics",
      "namespace": "anysdk.ProtocolAnalytics",
      "module": "anysdk",
      "description": "统计系统协议接口"
    },
    {
      "name": "ProtocolCrash",
      "namespace": "anysdk.ProtocolCrash",
      "module": "anysdk",
      "description": "崩溃分析系统协议接口"
    },
    {
      "name": "ProtocolCustom",
      "namespace": "anysdk.ProtocolCustom",
      "module": "anysdk",
      "description": "自定义系统协议接口"
    },
    {
      "name": "ProtocolIAP",
      "namespace": "anysdk.ProtocolIAP",
      "module": "anysdk",
      "description": "支付系统协议接口"
    },
    {
      "name": "ProtocolPush",
      "namespace": "anysdk.ProtocolPush",
      "module": "anysdk",
      "description": "推送系统协议接口"
    },
    {
      "name": "ProtocolREC",
      "namespace": "anysdk.ProtocolREC",
      "module": "anysdk",
      "description": "录屏系统协议接口"
    },
    {
      "name": "ProtocolShare",
      "namespace": "anysdk.ProtocolShare",
      "module": "anysdk",
      "description": "分享系统协议接口"
    },
    {
      "name": "ProtocolSocial",
      "namespace": "anysdk.ProtocolSocial",
      "module": "anysdk",
      "description": "社交系统协议接口"
    },
    {
      "name": "ProtocolUser",
      "namespace": "anysdk.ProtocolUser",
      "module": "anysdk",
      "description": "用户系统协议接口"
    },
    {
      "name": "Quat",
      "namespace": "cc.Quat",
      "module": "cc",
      "description": "表示 2D 向量和坐标"
    },
    {
      "name": "RawAsset",
      "namespace": "cc.RawAsset",
      "module": "cc",
      "description": "注册用的资源基类。"
    },
    {
      "name": "Rect",
      "namespace": "cc.Rect",
      "module": "cc",
      "description": "通过位置和宽高定义的 2D 矩形。"
    },
    {
      "name": "RenderComponent",
      "namespace": "cc.RenderComponent",
      "module": "cc",
      "description": "所有支持渲染的组件的基类"
    },
    {
      "name": "RenderTexture",
      "namespace": "cc.RenderTexture",
      "module": "cc",
      "description": "Render textures are textures that can be rendered to."
    },
    {
      "name": "ResolutionPolicy",
      "namespace": "cc.ResolutionPolicy",
      "module": "cc",
      "description": "<p>cc.ResolutionPolicy class is the root strategy class of scale strategy,\nits main task is to maintain the compatibility with Cocos2d-x</p>"
    },
    {
      "name": "RevoluteJoint",
      "namespace": "cc.RevoluteJoint",
      "module": "cc",
      "description": "旋转关节可以约束两个刚体围绕一个点来进行旋转。\n你可以通过开启关节限制来限制旋转的最大角度和最小角度。\n你可以通过开启马达来施加一个扭矩力来驱动这两个刚体在这一点上的相对速度。"
    },
    {
      "name": "RichText",
      "namespace": "cc.RichText",
      "module": "cc",
      "description": "富文本组件"
    },
    {
      "name": "RigidBody",
      "namespace": "cc.RigidBody",
      "module": "cc",
      "description": ""
    },
    {
      "name": "RopeJoint",
      "namespace": "cc.RopeJoint",
      "module": "cc",
      "description": "绳子关节只指定两个刚体间的最大距离，没有其他的效果。\n注意：如果你试图动态修改关节的长度，这有可能会得到一些意外的效果。"
    },
    {
      "name": "Scene",
      "namespace": "cc.Scene",
      "module": "cc",
      "description": "cc.Scene 是 cc.Node 的子类，仅作为一个抽象的概念。<br/>\ncc.Scene 和 cc.Node 有点不同，用户不应直接修改 cc.Scene。"
    },
    {
      "name": "SceneAsset",
      "namespace": "cc.SceneAsset",
      "module": "cc",
      "description": "场景资源类。"
    },
    {
      "name": "Scheduler",
      "namespace": "cc.Scheduler",
      "module": "cc",
      "description": "Scheduler 是负责触发回调函数的类。<br/>\n通常情况下，建议使用 cc.director.getScheduler() 来获取系统定时器。<br/>\n有两种不同类型的定时器：<br/>\n    - update 定时器：每一帧都会触发。您可以自定义优先级。<br/>\n    - 自定义定时器：自定义定时器可以每一帧或者自定义的时间间隔触发。<br/>\n如果希望每帧都触发，应该使用 update 定时器，使用 update 定时器更快，而且消耗更少的内存。"
    },
    {
      "name": "ScrollView",
      "namespace": "cc.ScrollView",
      "module": "cc",
      "description": "滚动视图组件"
    },
    {
      "name": "Scrollbar",
      "namespace": "cc.Scrollbar",
      "module": "cc",
      "description": "滚动条组件"
    },
    {
      "name": "Size",
      "namespace": "cc.Size",
      "module": "cc",
      "description": "cc.Size 是 size 对象的类。<br/>\n请不要使用它的构造函数创建的 size，<br/>\n使用 <a href=\"../modules/cc.html#method_size\" class=\"crosslink\">size</a> 别名函数。<br/>\n它不久将被取消，请使用cc.Vec2代替。"
    },
    {
      "name": "Skeleton",
      "namespace": "sp.Skeleton",
      "module": "sp",
      "description": "Spine 骨骼动画 <br/>\n<br/>\n(Skeleton 具有对骨骼数据的引用并且存储了骨骼实例的状态，\n它由当前的骨骼动作，slot 颜色，和可见的 slot attachments 组成。<br/>\n多个 Skeleton 可以使用相同的骨骼数据，其中包括所有的动画，皮肤和 attachments。"
    },
    {
      "name": "SkeletonData",
      "namespace": "sp.SkeletonData",
      "module": "sp",
      "description": "Spine 的 骨骼数据。"
    },
    {
      "name": "Slider",
      "namespace": "cc.Slider",
      "module": "cc",
      "description": "滑动器组件"
    },
    {
      "name": "Sprite",
      "namespace": "cc.Sprite",
      "module": "cc",
      "description": "该组件用于在场景中渲染精灵。"
    },
    {
      "name": "SpriteAtlas",
      "namespace": "cc.SpriteAtlas",
      "module": "cc",
      "description": "精灵图集资源类。"
    },
    {
      "name": "SpriteFrame",
      "namespace": "cc.SpriteFrame",
      "module": "cc",
      "description": "一个 SpriteFrame 包含：<br/>\n - 纹理：会被渲染组件使用的 Texture2D 对象。<br/>\n - 矩形：在纹理中的矩形区域。"
    },
    {
      "name": "SystemEvent",
      "namespace": "cc.SystemEvent",
      "module": "cc",
      "description": "系统事件，它目前支持按键事件和重力感应事件"
    },
    {
      "name": "SystemEvent.EventType",
      "namespace": "cc.SystemEvent.EventType",
      "module": "cc",
      "description": "SystemEvent 支持的事件类型"
    },
    {
      "name": "TTFFont",
      "namespace": "cc.TTFFont",
      "module": "cc",
      "description": "TTF 字体资源类。"
    },
    {
      "name": "TextAsset",
      "namespace": "cc.TextAsset",
      "module": "cc",
      "description": "文本资源类。"
    },
    {
      "name": "Texture2D",
      "namespace": "cc.Texture2D",
      "module": "cc",
      "description": "This class allows to easily create OpenGL or Canvas 2D textures from images or raw data."
    },
    {
      "name": "TiledLayer",
      "namespace": "cc.TiledLayer",
      "module": "cc",
      "description": "渲染 TMX layer。"
    },
    {
      "name": "TiledMap",
      "namespace": "cc.TiledMap",
      "module": "cc",
      "description": "在场景中渲染一个 tmx 格式的 Tile Map。"
    },
    {
      "name": "TiledMapAsset",
      "namespace": "cc.TiledMapAsset",
      "module": "cc",
      "description": "Class for tiled map asset handling."
    },
    {
      "name": "TiledObjectGroup",
      "namespace": "cc.TiledObjectGroup",
      "module": "cc",
      "description": "渲染 tmx object group。"
    },
    {
      "name": "TiledTile",
      "namespace": "cc.TiledTile",
      "module": "cc",
      "description": "TiledTile 可以单独对某一个地图块进行操作。\n他会将节点的旋转，缩放，平移操作应用在这个地图块上，并可以通过更换当前地图块的 gid 来更换地图块的显示样式。"
    },
    {
      "name": "Toggle",
      "namespace": "cc.Toggle",
      "module": "cc",
      "description": "Toggle 是一个 CheckBox，当它和 ToggleGroup 一起使用的时候，可以变成 RadioButton。"
    },
    {
      "name": "ToggleContainer",
      "namespace": "cc.ToggleContainer",
      "module": "cc",
      "description": "ToggleContainer 不是一个可见的 UI 组件，它可以用来修改一组 Toggle 组件的行为。<br/>\n当一组 Toggle 属于同一个 ToggleContainer 的时候，任何时候只能有一个 Toggle 处于选中状态。<br/>\n注意：所有包含 Toggle 组件的一级子节点都会自动被添加到该容器中"
    },
    {
      "name": "ToggleGroup",
      "namespace": "cc.ToggleGroup",
      "module": "cc",
      "description": "ToggleGroup 不是一个可见的 UI 组件，它可以用来修改一组 Toggle  组件的行为。当一组 Toggle 属于同一个 ToggleGroup 的时候，\n任何时候只能有一个 Toggle 处于选中状态。"
    },
    {
      "name": "Touch",
      "namespace": "cc.Touch",
      "module": "cc",
      "description": "封装了触摸相关的信息。"
    },
    {
      "name": "TypeScript",
      "namespace": "cc.TypeScript",
      "module": "cc",
      "description": "TypeScript 资源类。"
    },
    {
      "name": "ValueType",
      "namespace": "cc.ValueType",
      "module": "cc",
      "description": "所有值类型的基类。"
    },
    {
      "name": "Vec2",
      "namespace": "cc.Vec2",
      "module": "cc",
      "description": "表示 2D 向量和坐标"
    },
    {
      "name": "Vec3",
      "namespace": "cc.Vec3",
      "module": "cc",
      "description": "表示 3D 向量和坐标"
    },
    {
      "name": "VideoPlayer",
      "namespace": "cc.VideoPlayer",
      "module": "cc",
      "description": "Video 组件，用于在游戏中播放视频"
    },
    {
      "name": "View",
      "namespace": "cc.View",
      "module": "cc",
      "description": "cc.view is the singleton object which represents the game window.<br/>\nIt's main task include: <br/>\n - Apply the design resolution policy<br/>\n - Provide interaction with the window, like resize event on web, retina display support, etc...<br/>\n - Manage the game view port which can be different with the window<br/>\n - Manage the content scale and translation<br/>\n<br/>\nSince the cc.view is a singleton, you don't need to call any constructor or create functions,<br/>\nthe standard way to use it is by calling:<br/>\n - cc.view.methodName(); <br/>"
    },
    {
      "name": "ViewGroup",
      "namespace": "cc.ViewGroup",
      "module": "cc",
      "description": "ViewGroup的事件处理比较特殊，因为 ViewGroup 里面的子节点关心的事件跟 ViewGroup 本身可能不一样。\n为了让子节点能够正确地处理事件，ViewGroup 需要注册 capture 阶段的事件，并且合理地处理 ViewGroup 之间的事件传递。\n请参考 ScrollView 的实现来获取更多信息。"
    },
    {
      "name": "WXSubContextView",
      "namespace": "cc.WXSubContextView",
      "module": "cc",
      "description": "WXSubContextView 可以用来控制微信小游戏平台开放数据域在主域中的视窗的位置。<br/>\n这个组件的节点尺寸决定了开放数据域内容在主域中的尺寸，整个开放数据域会被缩放到节点的包围盒范围内。<br/>\n在这个组件的控制下，用户可以更自由得控制开放数据域：<br/>\n1. 子域中可以使用独立的设计分辨率和适配模式<br/>\n2. 子域区域尺寸可以缩小到只容纳内容即可<br/>\n3. 子域的分辨率也可以被放大，以便获得更清晰的显示效果<br/>\n4. 用户输入坐标会被自动转换到正确的子域视窗中<br/>\n5. 子域内容贴图的更新由组件负责，用户不需要处理<br/>\n唯一需要注意的是，当子域节点的包围盒发生改变时，开发者需要使用 `updateSubContextViewport` 来手动更新子域视窗。"
    },
    {
      "name": "WebView",
      "namespace": "cc.WebView",
      "module": "cc",
      "description": "WebView 组件，用于在游戏中显示网页"
    },
    {
      "name": "WeldJoint",
      "namespace": "cc.WeldJoint",
      "module": "cc",
      "description": "熔接关节相当于将两个刚体粘在了一起。\n熔接关节可能会使某些东西失真，因为约束求解器算出的都是近似值。"
    },
    {
      "name": "WheelJoint",
      "namespace": "cc.WheelJoint",
      "module": "cc",
      "description": "轮子关节提供两个维度的自由度：旋转和沿着指定方向上位置的移动。\n你可以通过开启关节马达来使用马达驱动刚体的旋转。\n轮组关节是专门为机动车类型设计的。"
    },
    {
      "name": "Widget",
      "namespace": "cc.Widget",
      "module": "cc",
      "description": "Widget 组件，用于设置和适配其相对于父节点的边距，Widget 通常被用于 UI 界面，也可以用于其他地方。\nWidget 会自动调整当前节点的坐标和宽高，不过目前调整后的结果要到下一帧才能在脚本里获取到，除非你先手动调用 <a href=\"../classes/Widget.html#method_updateAlignment\" class=\"crosslink\">updateAlignment</a>。"
    },
    {
      "name": "WorldManifold",
      "namespace": "cc.WorldManifold",
      "module": "cc",
      "description": ""
    },
    {
      "name": "array",
      "namespace": "js.array",
      "module": "js",
      "description": ""
    },
    {
      "name": "audioEngine",
      "namespace": "cc.audioEngine",
      "module": "cc",
      "description": "cc.audioengine是单例对象。<br/>\n主要用来播放音频，播放的时候会返回一个 audioID，之后都可以通过这个 audioID 来操作这个音频对象。<br/>\n不使用的时候，请使用 cc.audioEngine.uncache(filePath); 进行资源释放 <br/>\n注意：<br/>\n在 Android 系统浏览器上，不同浏览器，不同版本的效果不尽相同。<br/>\n比如说：大多数浏览器都需要用户物理交互才可以开始播放音效，有一些不支持 WebAudio，<br/>\n有一些不支持多音轨播放。总之如果对音乐依赖比较强，请做尽可能多的测试。"
    },
    {
      "name": "constructor",
      "namespace": "cc.Acceleration",
      "module": "cc",
      "description": "设备重力传感器传递的各个轴的数据。"
    },
    {
      "name": "debug",
      "namespace": "cc.debug",
      "module": "cc",
      "description": "包含游戏主体信息并负责驱动游戏的游戏对象。"
    },
    {
      "name": "game",
      "namespace": "cc.game",
      "module": "cc",
      "description": "包含游戏主体信息并负责驱动游戏的游戏对象。"
    },
    {
      "name": "loader",
      "namespace": "cc.loader",
      "module": "cc",
      "description": "Loader for resource loading process. It's a singleton object."
    },
    {
      "name": "macro",
      "namespace": "cc.macro",
      "module": "cc",
      "description": "Predefined constants"
    },
    {
      "name": "misc",
      "namespace": "cc.misc",
      "module": "cc",
      "description": "misc utilities"
    },
    {
      "name": "path",
      "namespace": "cc.path",
      "module": "cc",
      "description": "用于处理文件与目录的路径的模块"
    },
    {
      "name": "renderer",
      "namespace": "cc.renderer",
      "module": "cc",
      "description": "提供基础渲染接口的渲染器对象，渲染层的基础接口将逐步开放给用户"
    },
    {
      "name": "screen",
      "namespace": "cc.screen",
      "module": "cc",
      "description": "The fullscreen API provides an easy way for web content to be presented using the user's entire screen.\nIt's invalid on safari, QQbrowser and android browser"
    },
    {
      "name": "sys",
      "namespace": "cc.sys",
      "module": "cc",
      "description": "System variables"
    },
    {
      "name": "url",
      "namespace": "cc.url",
      "module": "cc",
      "description": ""
    },
    {
      "name": "visibleRect",
      "namespace": "cc.visibleRect",
      "module": "cc",
      "description": "cc.visibleRect is a singleton object which defines the actual visible rect of the current view,\nit should represent the same rect as cc.view.getViewportRect()"
    }
  ],
  "modules": [
    {
      "name": "GLOBAL-MACROS",
      "namespace": "GLOBAL-MACROS",
      "description": "这里是一些用来判断执行环境的宏，这些宏都是全局变量，直接访问即可。<br>\n在项目构建时，这些宏将会被预处理并根据构建的平台剔除不需要的代码，例如\n\n    if (CC_DEBUG) {\n        cc.log('debug');\n    }\n    else {\n        cc.log('release');\n    }\n\n在构建后会只剩下\n\n    cc.log('release');\n\n<br>\n如需判断脚本是否运行于指定平台，可以用如下表达式：\n\n    {\n        \"编辑器\":  CC_EDITOR,\n        \"编辑器 或 预览\":  CC_DEV,\n        \"编辑器 或 预览 或 构建调试\":  CC_DEBUG,\n        \"网页预览\":  CC_PREVIEW && !CC_JSB,\n        \"模拟器预览\":  CC_PREVIEW && CC_JSB,\n        \"构建调试\":  CC_BUILD && CC_DEBUG,\n        \"构建发行\":  CC_BUILD && !CC_DEBUG,\n    }"
    },
    {
      "name": "_decorator",
      "namespace": "cc._decorator",
      "module": "cc",
      "description": "一些 JavaScript 装饰器，目前可以通过 \"cc._decorator\" 来访问。\n（这些 API 仍不完全稳定，有可能随着 JavaScript 装饰器的标准实现而调整）"
    },
    {
      "name": "anysdk",
      "namespace": "anysdk",
      "description": "AnySDK 为 CP 提供一套第三方 SDK 接入解决方案，整个接入过程，不改变任何 SDK 的功能、特性、参数等，对于最终玩家而言是完全透明无感知的。\n目的是让 CP 商能有更多时间更专注于游戏本身的品质，所有 SDK 的接入工作统统交给我们吧。第三方 SDK 包括了渠道SDK、用户系统、支付系统、广告系统、统计系统、分享系统等等。"
    },
    {
      "name": "cc",
      "namespace": "cc",
      "module": "js",
      "description": "Cocos 引擎的主要命名空间，引擎代码中所有的类，函数，属性和常量都在这个命名空间中定义。"
    },
    {
      "name": "dragonBones",
      "namespace": "dragonBones",
      "description": "DragonBones 的全局的命名空间，\n与 DragonBones 相关的所有的类，函数，属性，常量都在这个命名空间中定义。"
    },
    {
      "name": "js",
      "namespace": "cc.js",
      "module": "cc",
      "description": "This module provides some JavaScript utilities.\nAll members can be accessed with \"cc.js\"."
    },
    {
      "name": "sp",
      "namespace": "sp",
      "description": "Spine 的全局的命名空间，\n与 Spine 相关的所有的类，函数，属性，常量都在这个命名空间中定义。"
    },
    {
      "name": "sp.spine",
      "namespace": "sp.spine",
      "description": "sp.spine 模块是 Spine 官方运行库的 API 入口，由 Spine 官方统一实现和维护，具体用法请参考：[http://zh.esotericsoftware.com/spine-using-runtimes](http://zh.esotericsoftware.com/spine-using-runtimes)"
    }
  ]
}